{"ast":null,"code":"import { Card, AbilityRarity } from './Card';\nimport { GlobalCardStats, triggersAndEffects } from './CardStats';\n\n/**\n * Generates random card stats and assigns a random trigger and effect based on the card's rarity.\n * @returns {Card} - The generated card with random stats, trigger, and effect.\n */\nfunction generateRandomCardStats() {\n  const card = new Card();\n\n  // Assign random stats to the card within the defined ranges\n  card.Accuracy = getRandomInt(GlobalCardStats.accuracy[0], GlobalCardStats.accuracy[1] + 1);\n  card.Retaliation = getRandomInt(GlobalCardStats.defense[0], GlobalCardStats.defense[1] + 1);\n  card.Damage = getRandomInt(GlobalCardStats.damage[0], GlobalCardStats.damage[1] + 1);\n  card.HealthPoints = getRandomInt(GlobalCardStats.health[0], GlobalCardStats.health[1] + 1);\n\n  // Generate a random rarity for the card\n  card.abilityRarity = generateRandomRarity();\n\n  // Generate a random trigger and effect based on the card's rarity\n  const triggerEffect = generateRandomTriggerEffect(card.abilityRarity);\n  card.Trigger = triggerEffect.trigger;\n  card.Effect = triggerEffect.effect;\n  return card;\n}\n\n/**\n * Generates a random rarity for the card based on predefined weights.\n * @returns {AbilityRarity} - The generated rarity.\n */\nfunction generateRandomRarity() {\n  const rarityWeights = {\n    [AbilityRarity.Common]: 0.8,\n    // Weight for common rarity\n    [AbilityRarity.Uncommon]: 0.5,\n    // Weight for uncommon rarity\n    [AbilityRarity.Rare]: 0.2 // Weight for rare rarity\n  };\n  const totalWeight = Object.values(rarityWeights).reduce((acc, weight) => acc + weight, 0);\n  const randomValue = Math.random() * totalWeight;\n  let cumulativeWeight = 0;\n\n  // Select a rarity based on the random value\n  for (const [rarity, weight] of Object.entries(rarityWeights)) {\n    cumulativeWeight += weight;\n    if (randomValue < cumulativeWeight) {\n      return rarity;\n    }\n  }\n  return AbilityRarity.Common; // Default to common if no rarity is selected\n}\n\n/**\n * Generates a random trigger and effect based on the card's rarity.\n * @param {AbilityRarity} rarity - The rarity of the card.\n * @returns {Object} - An object containing the selected trigger and effect.\n */\nfunction generateRandomTriggerEffect(rarity) {\n  // Filter triggers based on the card's rarity\n  const filteredTriggers = triggersAndEffects.filter(te => te.rarity === rarity.toLowerCase());\n  // Select a random trigger\n  const trigger = getRandomElementWithWeight(filteredTriggers);\n  // Select a random effect from the chosen trigger's effects\n  const effect = getRandomElementWithWeight(trigger.effects);\n  return {\n    trigger: trigger.trigger,\n    effect: effect.name\n  };\n}\n\n/**\n * Selects a random element from an array based on their weights.\n * @param {Array} elements - The array of elements to choose from.\n * @returns {Object} - The selected element.\n */\nfunction getRandomElementWithWeight(elements) {\n  const totalWeight = elements.reduce((acc, element) => acc + parseFloat(element.weight), 0);\n  const randomValue = Math.random() * totalWeight;\n  let cumulativeWeight = 0;\n\n  // Select an element based on the random value\n  for (const element of elements) {\n    cumulativeWeight += parseFloat(element.weight);\n    if (randomValue < cumulativeWeight) {\n      return element;\n    }\n  }\n  return elements[0]; // Fallback to the first element if no element is selected\n}\n\n/**\n * Selects a random element from an array.\n * @param {Array} arr - The array to select from.\n * @returns {any} - The selected element.\n */\nfunction getRandomElement(arr) {\n  return arr[Math.floor(Math.random() * arr.length)];\n}\n\n/**\n * Generates a random integer between the specified min (inclusive) and max (exclusive).\n * @param {number} min - The minimum value.\n * @param {number} max - The maximum value.\n * @returns {number} - The generated random integer.\n */\nfunction getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min)) + min;\n}\nexport default generateRandomCardStats;","map":{"version":3,"names":["Card","AbilityRarity","GlobalCardStats","triggersAndEffects","generateRandomCardStats","card","Accuracy","getRandomInt","accuracy","Retaliation","defense","Damage","damage","HealthPoints","health","abilityRarity","generateRandomRarity","triggerEffect","generateRandomTriggerEffect","Trigger","trigger","Effect","effect","rarityWeights","Common","Uncommon","Rare","totalWeight","Object","values","reduce","acc","weight","randomValue","Math","random","cumulativeWeight","rarity","entries","filteredTriggers","filter","te","toLowerCase","getRandomElementWithWeight","effects","name","elements","element","parseFloat","getRandomElement","arr","floor","length","min","max"],"sources":["/Users/chacenielson/Documents/git-pull/card-generator/src/card-logic/CardGenerator.js"],"sourcesContent":["import { Card, AbilityRarity } from './Card';\nimport { GlobalCardStats, triggersAndEffects } from './CardStats';\n\n/**\n * Generates random card stats and assigns a random trigger and effect based on the card's rarity.\n * @returns {Card} - The generated card with random stats, trigger, and effect.\n */\nfunction generateRandomCardStats() {\n  const card = new Card();\n\n  // Assign random stats to the card within the defined ranges\n  card.Accuracy = getRandomInt(GlobalCardStats.accuracy[0], GlobalCardStats.accuracy[1] + 1);\n  card.Retaliation = getRandomInt(GlobalCardStats.defense[0], GlobalCardStats.defense[1] + 1);\n  card.Damage = getRandomInt(GlobalCardStats.damage[0], GlobalCardStats.damage[1] + 1);\n  card.HealthPoints = getRandomInt(GlobalCardStats.health[0], GlobalCardStats.health[1] + 1);\n\n  // Generate a random rarity for the card\n  card.abilityRarity = generateRandomRarity();\n\n  // Generate a random trigger and effect based on the card's rarity\n  const triggerEffect = generateRandomTriggerEffect(card.abilityRarity);\n  card.Trigger = triggerEffect.trigger;\n  card.Effect = triggerEffect.effect;\n\n  return card;\n}\n\n/**\n * Generates a random rarity for the card based on predefined weights.\n * @returns {AbilityRarity} - The generated rarity.\n */\nfunction generateRandomRarity() {\n  const rarityWeights = {\n    [AbilityRarity.Common]: 0.8, // Weight for common rarity\n    [AbilityRarity.Uncommon]: 0.5, // Weight for uncommon rarity\n    [AbilityRarity.Rare]: 0.2 // Weight for rare rarity\n  };\n\n  const totalWeight = Object.values(rarityWeights).reduce((acc, weight) => acc + weight, 0);\n  const randomValue = Math.random() * totalWeight;\n  let cumulativeWeight = 0;\n\n  // Select a rarity based on the random value\n  for (const [rarity, weight] of Object.entries(rarityWeights)) {\n    cumulativeWeight += weight;\n    if (randomValue < cumulativeWeight) {\n      return rarity;\n    }\n  }\n\n  return AbilityRarity.Common; // Default to common if no rarity is selected\n}\n\n/**\n * Generates a random trigger and effect based on the card's rarity.\n * @param {AbilityRarity} rarity - The rarity of the card.\n * @returns {Object} - An object containing the selected trigger and effect.\n */\nfunction generateRandomTriggerEffect(rarity) {\n  // Filter triggers based on the card's rarity\n  const filteredTriggers = triggersAndEffects.filter(te => te.rarity === rarity.toLowerCase());\n  // Select a random trigger\n  const trigger = getRandomElementWithWeight(filteredTriggers);\n  // Select a random effect from the chosen trigger's effects\n  const effect = getRandomElementWithWeight(trigger.effects);\n\n  return { trigger: trigger.trigger, effect: effect.name };\n}\n\n/**\n * Selects a random element from an array based on their weights.\n * @param {Array} elements - The array of elements to choose from.\n * @returns {Object} - The selected element.\n */\nfunction getRandomElementWithWeight(elements) {\n  const totalWeight = elements.reduce((acc, element) => acc + parseFloat(element.weight), 0);\n  const randomValue = Math.random() * totalWeight;\n  let cumulativeWeight = 0;\n\n  // Select an element based on the random value\n  for (const element of elements) {\n    cumulativeWeight += parseFloat(element.weight);\n    if (randomValue < cumulativeWeight) {\n      return element;\n    }\n  }\n\n  return elements[0]; // Fallback to the first element if no element is selected\n}\n\n/**\n * Selects a random element from an array.\n * @param {Array} arr - The array to select from.\n * @returns {any} - The selected element.\n */\nfunction getRandomElement(arr) {\n  return arr[Math.floor(Math.random() * arr.length)];\n}\n\n/**\n * Generates a random integer between the specified min (inclusive) and max (exclusive).\n * @param {number} min - The minimum value.\n * @param {number} max - The maximum value.\n * @returns {number} - The generated random integer.\n */\nfunction getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n\nexport default generateRandomCardStats;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}