{"ast":null,"code":"import { Card, globalCardStats, triggersAndEffects, usePointDistributionSystem } from './CardStats';\n\n/**\n * Generates random card stats and assigns a random trigger and effect based on the card's rarity.\n * @returns {Card} - The generated card with random stats, trigger, and effect.\n */\nfunction generateRandomCardStats() {\n  const card = new Card();\n  if (usePointDistributionSystem) {\n    // Distribute points among the stats\n    const distributedStats = distributePoints(globalCardStats.distributionPoints);\n    console.log(\"distributedStats is \" + distributedStats);\n    card.HealthPoints = distributedStats.health;\n    card.Damage = distributedStats.damage;\n    card.Defense = distributedStats.defense;\n    card.Accuracy = distributedStats.accuracy;\n  } else {\n    // Assign random stats to the card within the defined ranges\n    card.AccuracyPoints = getRandomInt(globalCardStats.accuracyRange[0], globalCardStats.accuracyRange[1] + 1);\n    card.DefencePoints = getRandomInt(globalCardStats.defenseRange[0], globalCardStats.defenseRange[1] + 1);\n    card.DamagePoints = getRandomInt(globalCardStats.damageRange[0], globalCardStats.damageRange[1] + 1);\n    card.HealthPoints = getRandomInt(globalCardStats.healthRange[0], globalCardStats.healthRange[1] + 1);\n  }\n\n  // Generate a random trigger and effect\n  const triggerEffect = generateRandomTriggerEffect();\n  card.Trigger = triggerEffect.trigger;\n  card.Effect = triggerEffect.effect;\n  card.rarity = triggerEffect.rarity;\n  return card;\n}\n\n/**\n * Distributes a given number of points across four stats while respecting min and max values.\n * @param {number} totalPoints - The total points to distribute.\n * @returns {Object} - An object containing the distributed stats.\n */\nfunction distributePoints(totalPoints) {\n  // they results start at the min values\n  const setStats = {\n    health: globalCardStats.healthRange[0],\n    damage: globalCardStats.damageRange[0],\n    defense: globalCardStats.defenseRange[0],\n    accuracy: globalCardStats.accuracyRange[0]\n  };\n\n  // get the number of points already distributed based on min values of each stat\n  const currentlyDistributedPoints = Object.values(setStats).reduce((acc, stat) => acc + stat, 0);\n  console.log(currentlyDistributedPoints);\n  var pointsLeft = totalPoints - currentlyDistributedPoints;\n  for (let i = 0; i < pointsLeft; i++) {\n    // random number between 1 and 4\n    const statToIncrease = getRandomInt(1, 5);\n    console.log(statToIncrease);\n    switch (statToIncrease) {\n      case 1:\n        setStats.health++;\n        break;\n      case 2:\n        setStats.damage++;\n        break;\n      case 3:\n        setStats.defense++;\n        break;\n      case 4:\n        setStats.accuracy++;\n        break;\n      default:\n        // Handle the default case here\n        break;\n    }\n    pointsLeft--;\n  }\n  console.log(setStats);\n  return setStats;\n}\n\n/**\n * Generates a random trigger and effect based on their weights.\n * @returns {Object} - An object containing the selected trigger, effect, and rarity.\n */\nfunction generateRandomTriggerEffect() {\n  // Select a random trigger based on weights\n  const trigger = getRandomElementWithWeight(triggersAndEffects);\n\n  // Select a random effect from the chosen trigger's effects based on weights\n  const effect = getRandomElementWithWeight(trigger.effects);\n  return {\n    trigger: trigger.trigger,\n    effect: effect.name,\n    rarity: trigger.rarity\n  };\n}\n\n/**\n * Selects a random element from an array based on their weights.\n * @param {Array} elements - The array of elements to choose from.\n * @returns {Object} - The selected element.\n */\nfunction getRandomElementWithWeight(elements) {\n  const totalWeight = elements.reduce((acc, element) => acc + parseFloat(element.weight), 0);\n  const randomValue = Math.random() * totalWeight;\n  let cumulativeWeight = 0;\n\n  // Select an element based on the random value\n  for (const element of elements) {\n    cumulativeWeight += parseFloat(element.weight);\n    if (randomValue < cumulativeWeight) {\n      return element;\n    }\n  }\n  return elements[0]; // Fallback to the first element if no element is selected\n}\n\n/**\n * Generates a random integer between the specified min (inclusive) and max (exclusive).\n * @param {number} min - The minimum value.\n * @param {number} max - The maximum value.\n * @returns {number} - The generated random integer.\n */\nfunction getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min)) + min;\n}\nexport default generateRandomCardStats;","map":{"version":3,"names":["Card","globalCardStats","triggersAndEffects","usePointDistributionSystem","generateRandomCardStats","card","distributedStats","distributePoints","distributionPoints","console","log","HealthPoints","health","Damage","damage","Defense","defense","Accuracy","accuracy","AccuracyPoints","getRandomInt","accuracyRange","DefencePoints","defenseRange","DamagePoints","damageRange","healthRange","triggerEffect","generateRandomTriggerEffect","Trigger","trigger","Effect","effect","rarity","totalPoints","setStats","currentlyDistributedPoints","Object","values","reduce","acc","stat","pointsLeft","i","statToIncrease","getRandomElementWithWeight","effects","name","elements","totalWeight","element","parseFloat","weight","randomValue","Math","random","cumulativeWeight","min","max","floor"],"sources":["/Users/chacenielson/Documents/git-pull/card-generator/src/card-logic/CardGenerator.js"],"sourcesContent":["import { Card, globalCardStats, triggersAndEffects, usePointDistributionSystem } from './CardStats';\n\n/**\n * Generates random card stats and assigns a random trigger and effect based on the card's rarity.\n * @returns {Card} - The generated card with random stats, trigger, and effect.\n */\nfunction generateRandomCardStats() {\n  const card = new Card();\n\n  if (usePointDistributionSystem) {\n    // Distribute points among the stats\n    const distributedStats = distributePoints(globalCardStats.distributionPoints);\n    console.log(\"distributedStats is \" + distributedStats)\n    card.HealthPoints = distributedStats.health;\n    card.Damage = distributedStats.damage;\n    card.Defense = distributedStats.defense;\n    card.Accuracy = distributedStats.accuracy;\n\n  } else {\n    // Assign random stats to the card within the defined ranges\n    card.AccuracyPoints = getRandomInt(\n      globalCardStats.accuracyRange[0], \n      globalCardStats.accuracyRange[1] + 1\n    );\n    card.DefencePoints = getRandomInt(\n      globalCardStats.defenseRange[0], \n      globalCardStats.defenseRange[1] + 1\n    );\n    card.DamagePoints = getRandomInt(\n      globalCardStats.damageRange[0], \n      globalCardStats.damageRange[1] + 1\n    );\n    card.HealthPoints = getRandomInt(\n      globalCardStats.healthRange[0], \n      globalCardStats.healthRange[1] + 1\n    );\n  }\n\n  // Generate a random trigger and effect\n  const triggerEffect = generateRandomTriggerEffect();\n  card.Trigger = triggerEffect.trigger;\n  card.Effect = triggerEffect.effect;\n  card.rarity = triggerEffect.rarity;\n\n  return card;\n}\n\n/**\n * Distributes a given number of points across four stats while respecting min and max values.\n * @param {number} totalPoints - The total points to distribute.\n * @returns {Object} - An object containing the distributed stats.\n */\nfunction distributePoints(totalPoints) {\n  // they results start at the min values\n  const setStats = { \n    health: globalCardStats.healthRange[0], \n    damage: globalCardStats.damageRange[0], \n    defense: globalCardStats.defenseRange[0], \n    accuracy: globalCardStats.accuracyRange[0] \n  };\n\n  // get the number of points already distributed based on min values of each stat\n  const currentlyDistributedPoints = Object.values(setStats).reduce((acc, stat) => acc + stat, 0);\n  console.log(currentlyDistributedPoints)\n\n\n  var pointsLeft = totalPoints - currentlyDistributedPoints;\n\n\n  for( let i = 0; i < pointsLeft; i++){\n    // random number between 1 and 4\n    const statToIncrease = getRandomInt(1, 5);\n    console.log(statToIncrease)\n    switch(statToIncrease){\n      case 1:\n        setStats.health++;\n        break;\n      case 2:\n        setStats.damage++;\n        break;\n      case 3:\n        setStats.defense++;\n        break;\n      case 4:\n        setStats.accuracy++;\n        break;\n      default:\n        // Handle the default case here\n        break;\n    }\n    pointsLeft--;\n  }\n  console.log(setStats)\n\n  return setStats\n}\n\n/**\n * Generates a random trigger and effect based on their weights.\n * @returns {Object} - An object containing the selected trigger, effect, and rarity.\n */\nfunction generateRandomTriggerEffect() {\n  // Select a random trigger based on weights\n  const trigger = getRandomElementWithWeight(triggersAndEffects);\n  \n  // Select a random effect from the chosen trigger's effects based on weights\n  const effect = getRandomElementWithWeight(trigger.effects);\n\n  return { trigger: trigger.trigger, effect: effect.name, rarity: trigger.rarity };\n}\n\n/**\n * Selects a random element from an array based on their weights.\n * @param {Array} elements - The array of elements to choose from.\n * @returns {Object} - The selected element.\n */\nfunction getRandomElementWithWeight(elements) {\n  const totalWeight = elements.reduce((acc, element) => acc + parseFloat(element.weight), 0);\n  const randomValue = Math.random() * totalWeight;\n  let cumulativeWeight = 0;\n\n  // Select an element based on the random value\n  for (const element of elements) {\n    cumulativeWeight += parseFloat(element.weight);\n    if (randomValue < cumulativeWeight) {\n      return element;\n    }\n  }\n\n  return elements[0]; // Fallback to the first element if no element is selected\n}\n\n/**\n * Generates a random integer between the specified min (inclusive) and max (exclusive).\n * @param {number} min - The minimum value.\n * @param {number} max - The maximum value.\n * @returns {number} - The generated random integer.\n */\nfunction getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n\nexport default generateRandomCardStats;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}